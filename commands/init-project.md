---
description: Analyze codebase and initialize SolsDev documentation
argument-hint: [project-name]
---

# SolsDev - Initialize Project Documentation

You are setting up the SolsDev documentation structure by **analyzing the existing codebase** and creating intelligent, project-specific documentation.

## CRITICAL: Read Format Rules First

Before creating any files, read `templates/AGENT-INSTRUCTIONS.md` for 2025 documentation standards:

| Rule | Implementation |
|------|----------------|
| Root CLAUDE.md | < 60 lines, lean manifest |
| Tables over prose | `\| Column \| Column \|` format |
| File references | Point to `file:function` not code blocks |
| Error → Fix | `\| Issue \| Fix \|` tables |

## Project Information

Project name: $ARGUMENTS (or detect from package.json/directory name if not provided)

## Your Task: Analyze First, Then Document

### Step 1: Analyze the Codebase

**IMPORTANT:** Do NOT just copy empty templates. Analyze the project first!

Examine the codebase to understand:

1. **Tech Stack** (for STACK.md)
   - Check package.json, requirements.txt, Gemfile, go.mod, Cargo.toml
   - Identify framework (Next.js, React, Vue, etc.)
   - Database (PostgreSQL, MongoDB, etc.)
   - Key dependencies and their purposes
   - Deployment platform (Vercel, AWS, Heroku, etc.)

2. **Architecture** (for ARCHITECTURE.md)
   - Directory structure and organization
   - How components/modules are organized
   - Data flow patterns
   - API structure (REST, GraphQL, tRPC, etc.)
   - State management approach
   - Authentication/authorization patterns

3. **Code Patterns** (for PATTERNS.md)
   - File naming conventions (camelCase, kebab-case, etc.)
   - Component structure (hooks, props patterns)
   - Error handling patterns
   - API call patterns
   - Testing patterns (if tests exist)
   - Import organization

4. **Startup Commands** (for STARTUP.md)
   - Find dev/build/test commands in package.json scripts
   - Environment setup requirements (.env.example)
   - Database setup/migration commands
   - How to run single tests
   - Common development workflows

5. **Known Issues** (for GOTCHAS.md)
   - Check for TODO/FIXME comments
   - Look for workarounds in code comments
   - Check existing README or docs for known issues

### Step 2: Create Documentation Structure

Create both:
1. **CLAUDE.md** at project root (Claude's entry point - auto-discovered)
2. **.claude/** directory (detailed documentation - imported on-demand)

```bash
mkdir -p .claude
```

If `CLAUDE.md` or `.claude/` already exist, **ASK** the user if they want to overwrite existing files.

### Step 3: Generate Root CLAUDE.md (Lean Manifest)

Create `CLAUDE.md` at the project root with **lean, always-relevant context**:

This file should contain:
- **Project name** and brief 2-3 sentence description
- **Essential commands** (dev, test, build) from package.json
- **Core mandatory rules** (e.g., TDD workflow, git branch requirements, DO NOT touch legacy code)
- **@import statements** to reference detailed docs in .claude/

**Example structure:**
```markdown
# Project: [ProjectName]

*Generated by solsdev - Last updated: YYYY-MM-DD HH:MM*

## Quick Context
[2-3 sentence description from README or package.json]

## Essential Commands
```bash
[Actual commands from package.json scripts - dev, test, build]
```

## Core Principles
- MANDATORY: [Key rules discovered from codebase]
- DO NOT: [Anti-patterns to avoid]

## Documentation Maintenance
Mode: ask

The `doc-maintenance` skill will remind you to update documentation after:
- Adding/removing dependencies
- Changing architecture or patterns
- Refactoring code structure

Set to `auto` for automatic updates, or `ask` to be prompted (recommended).

Run `/solsdev:audit-docs` periodically to check for drift.

**Background Watcher:** The `doc-watcher` agent runs automatically after file changes to keep documentation synchronized.

## Imported Documentation

When working on specific areas, these detailed docs are auto-loaded:

@.claude/STACK.md - Tech stack with versions and rationale
@.claude/ARCHITECTURE.md - System design and component structure
@.claude/PATTERNS.md - Code conventions used in THIS project
@.claude/STARTUP.md - Setup guide and troubleshooting
@.claude/GOTCHAS.md - Known issues and workarounds
@.claude/DECISIONS.md - Architectural decision history
```

### Step 4: Generate Detailed Documentation in .claude/

Create these files in `.claude/` with **actual project-specific content** based on your analysis:

**INDEX.md** - Directory of documentation
- List all the documentation files
- Add current timestamp
- Customize descriptions for this specific project

**STACK.md** - Tech stack discovered from analysis
- Document the ACTUAL stack found in the project
- Explain WHY each technology was likely chosen
- Note version numbers from package.json/lock files

**ARCHITECTURE.md** - System design based on code structure
- Document the ACTUAL architecture you discovered
- Include component hierarchy
- Show data flow patterns found in the code
- Describe module boundaries

**PATTERNS.md** - Code conventions found in the codebase
- Document ACTUAL patterns used consistently in this project
- File naming conventions you observed
- Component/function structure patterns
- Import organization style
- NOT generic best practices - THIS project's patterns

**DECISIONS.md** - Start with timestamp, empty for user to fill
```markdown
# Architectural Decisions

*Last updated: YYYY-MM-DD HH:MM*

This log tracks significant architectural decisions made during development.

## Decision Template

When adding a decision, include:
- **Date**: When the decision was made
- **Context**: What problem we're solving
- **Decision**: What we decided to do
- **Consequences**: Trade-offs and implications

---

## [YYYY-MM-DD] Initial Project Setup

**Context:** Project initialized with thoughtful-dev documentation structure.

**Decision:** Analyzed codebase and documented existing architecture, stack, and patterns.

**Consequences:** Team has shared understanding of current state. Future decisions will be logged here.
```

**STARTUP.md** - Commands discovered from package.json and project files
- ACTUAL dev/build/test commands from this project
- Environment variables needed (from .env.example or code analysis)
- Database setup steps (if database detected)
- How to run single tests (actual test commands)
- Port numbers, URLs, credentials locations

**GOTCHAS.md** - Issues found during analysis
- Document any TODO/FIXME comments found
- Note unusual dependencies or configurations
- Mention if setup seems incomplete
- Empty template if nothing obvious found

### Step 5: Verify and Report

After creating documentation:

1. **List all created files:**
   - CLAUDE.md (root) with line count
   - All .claude/*.md files with line counts

2. **Highlight discoveries:**
   - Tech stack summary
   - Key architectural patterns found
   - Main entry points and commands

3. **Point out gaps:**
   - Areas needing human review
   - Missing information (e.g., no tests found, unclear deployment)
   - Questions for the user

4. **Explain the structure:**
   - CLAUDE.md = Claude's entry point (auto-loaded every session)
   - .claude/*.md = Detailed docs (loaded via @import when needed)
   - INDEX.md = Human-friendly documentation directory

## Important Principles

**DO:**
- Use the Explore agent or Task tool to analyze the codebase thoroughly
- Read actual files (package.json, main components, config files)
- Document what EXISTS, not what SHOULD exist
- Be specific with examples from the actual code
- Add timestamps in YYYY-MM-DD HH:MM format
- Ask before overwriting existing .claude/ files

**DON'T:**
- Copy generic templates without analysis
- Make assumptions about tech stack - verify it
- Document ideal patterns - document ACTUAL patterns
- Skip the analysis step
- Overwrite files without permission
- Use placeholder text - use real project data

## After Completion

Tell the user:

1. **What was discovered:**
   - Tech stack summary
   - Key architectural patterns
   - Main entry points and commands

2. **How the memory system works:**
   - **CLAUDE.md (root)** - Auto-loaded at the start of EVERY session
   - Contains essential commands and core rules
   - Uses @import to pull in detailed docs from .claude/
   - **Keeps context lean** to prevent pollution

3. **What to customize:**
   - **CLAUDE.md:** Review core principles and essential commands
   - **.claude/STACK.md:** Verify tech stack accuracy
   - **.claude/PATTERNS.md:** Confirm these are the patterns you want enforced
   - **.claude/DECISIONS.md:** Log architectural decisions as they're made
   - **.claude/GOTCHAS.md:** Update as new issues are discovered

4. **How to use the @import system:**
   - Claude automatically reads CLAUDE.md every session
   - When working on specific areas, Claude will read the imported files
   - Example: "Refactor the API" → Claude reads @.claude/ARCHITECTURE.md
   - Example: "Fix the tests" → Claude reads @.claude/PATTERNS.md for test conventions
   - You can manually tell Claude: "Read @.claude/STACK.md" if needed

5. **Progressive disclosure:**
   - Detailed docs are pulled in ONLY when needed
   - Prevents context bloat while maintaining comprehensive knowledge
   - Updates to .claude/*.md files automatically available via @import

6. **Living documentation:**
   - Use `#` prefix to quickly add new rules (e.g., `# Always use Zod for validation`)
   - Edit files directly when making larger changes
   - Update as architecture/patterns evolve
   - This documentation serves both humans AND Claude!

**Key principle:** CLAUDE.md is Claude's operating manual for YOUR project!

7. **Background doc-watcher:**
   - Automatically monitors file changes via PostToolUse hook
   - Runs as background agent after Write/Edit operations
   - Updates documentation incrementally
   - Works alongside manual `/solsdev:audit-docs` for comprehensive checks
